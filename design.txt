TODO:
	NEXT:
	1. More events!
	2. Add "impassable" booleans to some rooms (crew members cannot walk through them). Also update RoomConnections functions to check/filter out these rooms from paths.
	3. Room that can be used to buy any room you want + a resource system for this?
	4. Life support room (at some point, makes testing harder)
	5. Airlock room (must have one of these that is not leading to a courtyard at all times)
	6. Empty/isolation room or hallway (does nothing, some other rooms must be isolated from the rest of the ship using this)



ROOMS (also read the ROOM_GAMEPLAY and ROOM_CONNECTIONS sections)

When spawning a new room, call the init_room function and give the correct room data as a parameter
(these are in the room_data dict inside the RoomData script). That's all!
The function will create a room_info node for the room, and add it as a child of the Main node (since otherwise it will rotate with the room.)

A lit up room means that the room is ACTIVATED. Rooms always spawn UNACTIVATED,
and the activated status can be toggled by pressing middle mouse button over the room.
Note that some rooms are automatically activated after they have been connected, and some rooms cannot be deactivated once they have been activated.

If a room is picked up and then put down near or on top of another room, the connect_rooms()
method inside room.gd is called to see if the room connectors are close enough to connect. If not,
the room cannot be put down there.

If the room can be connected, it is, and the room_connected signal is emitted. Each room will listen to
this signal, and if the connectors in the emitted signal match their own connectors, they will react
accordingly. Everything that needs to be done AFTER rooms have been placed should therefore be in
the _on_room_connected function inside room.gd.


ROOM_GAMEPLAY
RoomGameplay.gd is instanced separately for each room, and it holds all functions and data related to the room's actual gameplay mechanics
(activation status, power usage, the amount of crew it supplies etc.).

Activating a room is complex, and it's split into two functions. When a room is activated by pressing MMB over it:
	1. Room.gd calls activate_room() inside RoomGameplay.gd, which checks if the room is set to be always_deactivated, and also checks if the room has a sufficient power supplier nearby (if the room requires power). These checks are made for every room type.
	2. If these checks succeed, the _try_to_activate() function is called, which checks various things depending on the room's type.
	(NOTE! If these checks succeed as well, this function will also e.g. send a signal that more crew members have been added to the station, so it does more than just return a boolean value to activate_room().)
	3. Finally, if the room can be activated, the activate_room() function will set the room's activated status to true, and change its Color to show that the room is now activated.
Deactivating a room is usually simpler, but follows the same structure.


ROOM_CONNECTIONS
RoomConnections.gd contains static functions that either help with the connecting of rooms,
check if two rooms can be next to each other according to the rules,
or find paths through the station.
For example the distance_between() function finds the shortest distance between any two rooms.
NOTE: Since the functions are static, this script should not be instanced anywhere. Just use them.




RoomData (IMPORTANT!)
Lots of stuff in RoomData should probably be moved elsewhere and reimplemented,
for example each room shape could have its own scene since there should not be that
many of them and it would be much better to see the rooms visually.


CREATING A NEW ROOM TYPE:
	1. Add the new room type (e.g. MY_ROOM) to the RoomType enum in RoomData.gd.
	(If the new room has a new, non-existing shape as well, add the shape to the RoomShape enum)
	2. Create a data dict for the room, e.g. _my_room_data = {}
	3. Add RoomType.MY_ROOM: _my_room_data to the room_data dict.
	4. If you created a new shape, update room_info_pos and
	room_connectors appropriately.
	5. Finally, if you created a new shape, add a polygon representing it to the "AllRoomShapes"
	node inside the Room scene, and update the (_ready(), create_clickable_area()) function in room.gd accordingly.
	(This should be simplified!)
